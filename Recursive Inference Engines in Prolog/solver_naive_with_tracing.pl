% gvim:  fileencoding=utf8

/** <module> A Simple Backtracking Inference Engine à la Prolog with Tracing

@author José Martinez
@see [[Polytechnic School of the University of Nantes][http://web.polytech.univ-nantes.fr/]]
@license All Rights Reserved

This code cannot be reproduced, copied, transmitted, etc., without the previous explicit authorisation of the author and/or the School.
It is provided only for a pedagogical usage at Polytech Nantes.

@version 1.1

__HISTORY__

   * 2014:  first version
   * January 2019:  modularisation;  documentation improvement
   * March 2019:  higher-order predicates

__USAGE__
  
To be imported by a problem (solution) module.

 */

:- module(solver_naive_with_tracing, [ solver/4 ]).
:- meta_predicate solver(1, 4, ?, ?).

%! solver(+F:  predicate(S:  state), +O:  predicate(D:  description, S:  state, NS:  state, C:  cost), +S:  state, -SS:  list(transition(D:  description, NS:  state, C:  cost))) is nondet.
%
% This is the _very basic_ backtracking solver... plus tracing.
%
% It can be safely used only for _finite_ and _directed acyclic_ state graphs.
% This engine closely mimics the way Prolog solves a problem.
% Hence it is generally not to be used!
% In particular, it founds _all_ the solutions, including the ones that are extensions of a previous one.
%
% This is the public predicate.
% It simply calls its internal counterpart, 'solver/3', by initialising the current depth, i.e., indentation level, to zero.
%
% __Nota.__ When the indentation depth is not too large, i.e., without line wrapping, nor too long, it is rather easy to retrieve the solution in the displayed tree.
% For each vertical bar, which represents a level in the reasoning tree, keep only the last "Try".
% For instance, in the following output:
%
% ==
% Try op_1:  ...
%  | Try op_2:  ...
%  |  | Try op_3:  ...
%  | Try op_4:  ...
%  |  | Try op_5:  ...
%  |  |  | Try op_6:  ...
%  |  |  |  | Try op_7:  ...
%  |  |  |  |  | Try op_8:  ...
%  |  |  |  |  |  | Try op_9:  ...
%  |  |  |  | Try op_10:  ...
%  |  |  |  |  | Try op_11:  ...
%  |  |  |  |  |  | Try op_12:  ...
%  |  |  | Try op_13:  ...
%  |  |  |  | Try op_14:  ...
%  |  |  |  |  | Try op_15:  ...
%  |  |  |  |  |  | Try op_16:  ...
%  |  |  |  | Try op_17:  ...
%  |  |  |  |  | Try op_18:  ...
%  |  |  |  |  |  | Try op_19:  ...
%  |  | Try op_20:  ...
%  |  |  | Try op_21:  ...
%  |  |  |  | Try op_22:  ...
%  |  |  |  |  | Try op_23:  ...
%  |  |  |  |  |  | Try op_24:  ...
%  |  |  |  |  |  |  | Try op_25:  ...
%  |  |  |  |  |  |  | Try op_26:  ...
%  |  |  |  |  |  |  |  | Try op_27:  ...
%  |  |  |  |  |  |  |  |  | Try op_28:  ...
%  |  |  |  |  |  |  |  |  |  | Try op_29:  ...
%  |  |  |  |  |  |  |  | Try op_30:  ...
%  |  |  |  |  |  |  |  |  | Try op_31:  ...
%  |  |  |  |  |  |  |  |  |  | Try op_32:  ...
%  |  |  |  |  |  |  |  |  |  |  |  Final state: ...
% ==
%
% reading the bars from left to right, then looking for the last "Try" in each bar, the solution comes as [op_1, op_4, op_20, op_21, op_22, op_23, op_24, op_26, op_30, op_31, op_32].
%
% @arg F   The final state predicate.
% @arg O   The operation predicate where D is a description of the applied operation (basically its name), S is the original state, NS is the resulting state, and C is the cost of this transition.
% @arg I   The initial state.
% @arg SS  The path from the initial state to a final one, excluding the initial state.
%
solver(F, O, I, SS) :-
   solver(F, O, I, SS, 0).

%! solver(+F:  predicate(S:  state), +O:  predicate(D:  description, S:  state, NS:  state, C:  cost), +S:  state, -SS:  list(transition(D:  description, NS:  state, C:  cost)), +T:  int) is nondet.
%
% Internal basic backtracking solver with tracing...
%
% @arg F   The final state predicate.
% @arg O   The operation predicate where D is a description of the applied operation (basically its name), S is the original state, NS is the resulting state, and C is the cost of this transition.
% @arg S   The initial (or some) state.
% @arg SS  The path from the initial state to a final one, excluding the initial state.
% @arg T   The depth of the search, to be used for tracing purposes.
%
solver(F, _, S, [], T) :-  % There is no transition in the solution...
   call(F, S),             % ... should the given state already be a final one (i.e., final_state(S)).
   writef("%rFinal state: %t\n", [' | ', T, S]).
solver(F, O, S, [transition(D, NS, C) | SS], T) :-  % The solution is the concatenation of...
   call(O, D, S, NS, C),                         % ... a transition from the current state (i.e., operation(D, S, NS, C)) and...
   writef("%rTry %t:  %t --%t--> %t\n", [' | ', T, D, S, C, NS]),
   plus(T, 1, T_plus_1),
   solver(F, O, NS, SS, T_plus_1).                 % ... the solution from the resulting state
solver(_, _, _, _, T) :-
   writef("%rNo (more) operation is possible\n", [' | ', T]),
   fail.

